/* ================== COOJA Simulation Script: Tự dừng khi im lặng ==================
 * Cách dùng: Tools → Simulation Script → dán toàn bộ → Run
 * Lưu ý: KHÔNG dùng trong Log Listener Script.
 */

/* ======= CẤU HÌNH THƯ MỤC/THỜI GIAN ======= */
var PATH_BASE = "/home/chuongvo/waco/examples/waco-srdcp/sim"; // <== ĐỔI NẾU CẦN
var CFG       = "cfg1_waco_srdcp";                              // <== ĐỔI NẾU CẦN
var SEED      = "seed_1234";                                     // <== ĐỔI NẾU CẦN

var SIM_SETTLING_TIME_MS = 20000;     // warm-up 20s
var MAX_DURATION_MS      = 1800000;   // giới hạn cứng 30 phút (phòng treo)
var QUIET_TIMEOUT_MS     = 120000;    // dừng nếu im lặng 120s sau warm-up
var MIN_RUNTIME_MS       = 60000;     // tối thiểu chạy 60s sau warm-up rồi mới cho phép dừng vì im lặng

/* ======= TẬP TAG HỢP LỆ ĐỂ TÍNH "CÓ HOẠT ĐỘNG" ======= */
var TAGS = ["UL_TX","UL_RX","DL_TX","DL_RX","PWR","SRDCP","BEACON"];

/* ======= TÊN FILE LOG ======= */
var CSV_PATH = PATH_BASE + "/" + CFG + "/" + SEED + "/log.csv";
var PT_PATH  = PATH_BASE + "/" + CFG + "/" + SEED + "/powertracker.txt";

/* ================== KHÔNG CẦN SỬA DƯỚI ĐÂY ================== */
try { load("nashorn:mozilla_compat.js"); } catch (err) {}
importPackage(java.io);
importPackage(java.util);

/* Helper: mở FileWriter và tự tạo thư mục cha */
function openWriter(path, append) {
  var f = new File(path);
  var parent = f.getParentFile();
  if (parent != null) parent.mkdirs();
  return new FileWriter(f, append === true);
}

/* Lấy plugin PowerTracker nếu có */
var ptplugin = sim.getCooja().getStartedPlugin("PowerTracker");
if (ptplugin != null) {
  try { ptplugin.reset(); } catch (ignore) {}
}

/* Mở file output */
var outLog = openWriter(CSV_PATH, false);
var outPwr = openWriter(PT_PATH,  false);

/* Đặt TIMEOUT tổng để bắt exception khi quá giờ */
TIMEOUT(MAX_DURATION_MS);

/* Gửi mốc kết thúc warm-up */
GENERATE_MSG(SIM_SETTLING_TIME_MS, "SIM_SETTLING_DONE");

/* Trạng thái mô phỏng */
var settled = false;
var lastActivitySimTime = 0;   // mốc thời gian mô phỏng có log hợp lệ gần nhất (sau warm-up)
var settleDoneSimTime   = -1;  // thời điểm mô phỏng kết thúc warm-up

/* Tiện ích: có phải một log hợp lệ (bắt đầu bằng TAG) không? */
function isTaggedMessage(s) {
  if (!s) return false;
  for (var i = 0; i < TAGS.length; i++) {
    if (s.startsWith(TAGS[i] + ",")) return true;
  }
  return false;
}

/* Tiện ích: flush định kỳ (10s mô phỏng) */
function periodicFlush(simTime) {
  if ((simTime % 10000) === 0) {
    try { outLog.flush(); } catch (ignore) {}
    try { outPwr.flush(); } catch (ignore) {}
  }
}

/* Kết thúc gọn gàng: ghi PowerTracker 1 lần cuối, đóng file, ném exception để dừng script */
function finishExperiment(reason) {
  try {
    if (ptplugin != null) {
      var stats = ptplugin.radioStatistics();
      outPwr.write(String(stats) + "\n");
    }
  } catch (ignore) {}

  try { outLog.close(); } catch (ignore) {}
  try { outPwr.close(); } catch (ignore) {}

  throw("experiment finished: " + reason);
}

while (true) {
  try {
    YIELD(); // chờ sự kiện (log mới / timer ...)
  } catch (e) {
    // TIMEOUT tổng ném exception -> kết thúc
    finishExperiment("max_duration_timeout");
  }

  // Sau warm-up: reset PowerTracker, đánh dấu thời điểm bắt đầu tính QUIET
  if (msg && msg.equals("SIM_SETTLING_DONE")) {
    if (ptplugin != null) {
      try { ptplugin.reset(); } catch (ignore) {}
    }
    settled = true;
    settleDoneSimTime = time;
    // Header gợi ý (có thể bỏ)
    outLog.write("# LOG CSV (WaCo+SRDCP) after warm-up\n");
    outLog.flush();
    continue;
  }

  // Ghi log & theo dõi hoạt động chỉ sau warm-up
  if (settled && msg != null) {
    // Ghi nguyên nội dung msg (định dạng CSV có TAG đầu dòng)
    // Nếu bạn muốn giữ định dạng "time\tID:\tmsg" thì đổi dòng dưới thành:
    // outLog.write(time + "\tID:" + id + "\t" + msg + "\n");
    outLog.write(msg + "\n");

    // Nếu là dòng hợp lệ theo TAG, cập nhật mốc hoạt động
    if (isTaggedMessage(msg)) {
      lastActivitySimTime = time;
    }

    periodicFlush(time);
  }

  /* Cơ chế tự dừng khi im lặng:
   * - Chỉ xét sau warm-up và sau khi đã chạy tối thiểu MIN_RUNTIME_MS từ mốc settle
   * - Nếu đã từng thấy hoạt động hợp lệ (lastActivitySimTime > 0)
   * - Và (time - lastActivitySimTime) >= QUIET_TIMEOUT_MS -> dừng
   */
  if (settled &&
      settleDoneSimTime >= 0 &&
      (time - settleDoneSimTime) >= MIN_RUNTIME_MS &&
      lastActivitySimTime > 0 &&
      (time - lastActivitySimTime) >= QUIET_TIMEOUT_MS) {
    finishExperiment("quiet_timeout_" + QUIET_TIMEOUT_MS + "ms");
  }
}
